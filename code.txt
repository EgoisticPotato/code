Q1. A potentiometer is connected to an analog input pin of the Arduino UNO. 
  The analog value (0–1023) must be read, displayed on the Serial Monitor, and mapped to control the brightness of an LED connected to a PWM pin (e.g., pin 9). 
  The LED should glow with varying intensity corresponding to the potentiometer position.
// CONNECTIONS:
// Potentiometer wiper (middle) -> A0
// Potentiometer outer 1        -> 5V
// Potentiometer outer 2        -> GND
// LED anode (long leg)         -> D9 (PWM) through 220Ω
// LED cathode (short leg)      -> GND

const int potPin = A0;
const int ledPin = 9;
int potValue = 0;
int ledValue = 0;

void setup() {
  Serial.begin(9600);
  pinMode(ledPin, OUTPUT);
}

void loop() {
  potValue = analogRead(potPin);
  ledValue = map(potValue, 0, 1023, 0, 255);

  analogWrite(ledPin, ledValue);
  Serial.print("Potentiometer Value: ");
  Serial.print(potValue);
  Serial.print("\t Mapped LED Value: ");
  Serial.println(ledValue);

  delay(100);
}
-------------------------------------------------------------------
Q2. Design an Arduino program to read the state of a push button connected to a digital input pin and display its status (“Button Pressed” / “Button Released”) on the Serial Monitor. 
    When the button is pressed, the on-board LED (pin 13) should turn ON; otherwise, it should remain OFF.
// CONNECTIONS:
// Button side 1          -> 5V
// Button side 2          -> D2
// Same as D2             -> 10kΩ -> GND  (external pull-down)
// Using onboard LED at D13

const int buttonPin = 2;
const int ledPin = 13;
int buttonState = 0;

void setup() {
  pinMode(buttonPin, INPUT);
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
}

void loop() {
  buttonState = digitalRead(buttonPin);
  
  if (buttonState == HIGH) {
    Serial.println("Button Pressed");
    digitalWrite(ledPin, HIGH);
  } else {
    Serial.println("Button Released");
    digitalWrite(ledPin, LOW);
  }
  
  delay(200);
}

-------------------------------------------------------------
Q3. Control the on-board LED (pin 13) to blink in different patterns based on user input via Serial Monitor:
    Mode 1 = 1s ON / 1s OFF, Mode 2 = 200ms ON / 200ms OFF, Mode 3 = Gradual ON duration from 100ms to 1000ms (reset, repeat).
// CONNECTIONS:
// USB only for Serial
// Using onboard LED at D13

const int ledPin = 13;
char userInput;
int mode = 0;  

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);

  Serial.println("=== LED Blink Controller ===");
  Serial.println("Enter a mode:");
  Serial.println("1 - Standard Blink (1s ON, 1s OFF)");
  Serial.println("2 - Fast Blink (200ms ON, 200ms OFF)");
  Serial.println("3 - Gradual Blink (100ms → 1000ms)");
  Serial.println("S - Stop Blinking");
  Serial.println("=============================");
}

void loop() {
  // --- Read User Input ---
  if (Serial.available() > 0) {
    userInput = Serial.read();       // Read the character
    if (userInput == '1') {
      mode = 1;
      running = true;
      Serial.println("Mode 1 Selected: Standard Blink");
    }
    else if (userInput == '2') {
      mode = 2;
      running = true;
      Serial.println("Mode 2 Selected: Fast Blink");
    }
    else if (userInput == '3') {
      mode = 3;
      running = true;
      Serial.println("Mode 3 Selected: Gradual Blink");
    }
    else if (userInput == 'S' || userInput == 's') {
      mode = 0;
      running = false;
      digitalWrite(ledPin, LOW);
      Serial.println("Blinking stopped. LED OFF.");
    }
    else {
      Serial.println("Invalid input! Enter 1, 2, 3, or S.");
    }
  }

  if (running){
    switch (mode) {
      case 1: // Standard Blink
        digitalWrite(ledPin, HIGH);
        Serial.println("Mode 1: LED ON (1s)");
        delay(1000);
        digitalWrite(ledPin, LOW);
        Serial.println("Mode 1: LED OFF (1s)");
        delay(1000);
        break;
  
      case 2: // Fast Blink
        digitalWrite(ledPin, HIGH);
        Serial.println("Mode 2: LED ON (200ms)");
        delay(200);
        digitalWrite(ledPin, LOW);
        Serial.println("Mode 2: LED OFF (200ms)");
        delay(200);
        break;
  
      case 3: // Gradual Blink
        for (int onTime = 100; onTime <= 1000 && mode == 3; onTime += 100) {
          digitalWrite(ledPin, HIGH);
          Serial.print("Mode 3: LED ON (");
          Serial.print(onTime);
          Serial.println(" ms)");
          delay(onTime);
  
          digitalWrite(ledPin, LOW);
          Serial.println("Mode 3: LED OFF (200 ms)");
          delay(200);
  
      default:
        // Mode = 0 (stopped) or invalid
        digitalWrite(ledPin, LOW);
        break;
    }
  }
}
----------------------------------------------
Q4. Gradually increase and decrease the brightness of an LED on a PWM pin (e.g., D9) using PWM. 
    Display the PWM values on the Serial Monitor.
// CONNECTIONS:
// LED anode (long)  -> D9 (PWM) through 220Ω
// LED cathode       -> GND

const int LED_PIN = 9;

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(9600);
}

void loop() {
  for (int b = 0; b <= 255; b++) {
    analogWrite(LED_PIN, b);
    Serial.print("PWM: "); 
    Serial.println(b);
    delay(5);
  }
  for (int b = 255; b >= 0; b--) {
    analogWrite(LED_PIN, b);
    Serial.print("PWM: "); 
    Serial.println(b);
    delay(5);
  }
}
------------------------------------------------------------------
Q5. Measure an analog voltage (0–5V) on A0, convert ADC to voltage, print both ADC and voltage to Serial Monitor, and stream voltage for Serial Plotter.
// CONNECTIONS:
// Pot wiper (middle) -> A0
// Pot outer 1        -> 5V
// Pot outer 2        -> GND

const int analogPin = A0;
int adcValue = 0;
float voltage = 0.0;

void setup() {
  Serial.begin(9600);
  Serial.println("Analog Voltage Measurement Started");
  Serial.println("ADC Value\tVoltage (V)");
}

void loop() {
  adcValue = analogRead(analogPin);
  voltage = (adcValue * 5.0) / 1023.0;

  // Display on Serial Monitor
  Serial.print(adcValue);
  Serial.print("\t\t");
  Serial.println(voltage, 3);

  // For Serial Plotter (optional visualization)
  // Serial.println(voltage);   // Uncomment if using Serial Plotter instead

  delay(200);  // Delay for stability
}
-----------------------------------------------------------------------
Q6. Read analog input from a potentiometer and determine whether the knob is rotating clockwise, counterclockwise, or not moving, with a small threshold for noise.
// CONNECTIONS:
// Pot wiper (middle) -> A0
// Pot outer 1        -> 5V
// Pot outer 2        -> GND

const int potPin = A0;
int currentValue = 0;
int threshold = 10;

void setup() {
  Serial.begin(9600);
  Serial.println("Potentiometer Rotation Detection Started");
  previousValue = analogRead(potPin);
}

void loop() {
  currentValue = analogRead(potPin);
  
  if (currentValue > previousValue + threshold) {
    Serial.println("Rotating Clockwise");
  } 
  else if (currentValue < previousValue - threshold) {
    Serial.println("Rotating Counterclockwise");
  } 
  else {
    Serial.println("No Movement");
  }

  previousValue = currentValue;
  delay(200);
}
----------------------------------------------------------------
Q7. Blink the on-board LED using delays that follow the Fibonacci sequence in milliseconds (e.g., 100, 100, 200, 300, 500, 800, …). 
    After the 8th term, restart.
// CONNECTIONS:
// Using onboard LED at D13

const int ledPin = 13;  // On-board LED pin
int a = 100;
int b = 100;
int nextTerm;
int count = 0;

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Fibonacci LED Blinking Started");
}

void loop() {
  digitalWrite(ledPin, HIGH);
  delay(a);
  digitalWrite(ledPin, LOW);
  delay(a);

  Serial.print("Fibonacci Term ");
  Serial.print(count + 1);
  Serial.print(": ");
  Serial.print(a);
  Serial.println(" ms");

  nextTerm = a + b;
  a = b;
  b = nextTerm;
  count++;

  if (count >= 8) {
    a = 100;
    b = 100;
    count = 0;
    Serial.println("---- Restarting Fibonacci Sequence ----");
  }
}
------------------------------------------------------------------
Q8. Use a push button on D2. Each short press increases a counter by 1 and prints it on Serial. 
    Holding for ≥3 seconds resets the counter to 0.
// CONNECTIONS:
// Button side 1 -> 5V
// Button side 2 -> D2
// Same as D2    -> 10kΩ -> GND (pull-down)

const int buttonPin = 2;
int buttonState = 0;
int lastButtonState = 0;
unsigned long pressStartTime = 0;
unsigned long pressDuration = 0;
int counter = 0;

void setup() {
  pinMode(buttonPin, INPUT);
  Serial.begin(9600);
  Serial.println("Button Counter Started");
}

void loop() {
  buttonState = digitalRead(buttonPin);

  // Detect button press
  if (buttonState == HIGH && lastButtonState == LOW) {
    pressStartTime = millis();
  }

  // Detect button release
  if (buttonState == LOW && lastButtonState == HIGH) {
    pressDuration = millis() - pressStartTime;

    if (pressDuration < 3000) {
      counter++;  // Short press → increment counter
      Serial.print("Short Press Detected | Count = ");
      Serial.println(counter);
    } 
    else {
      counter = 0;
      Serial.println("Long Press Detected | Counter Reset to 0");
    }
  }

  lastButtonState = buttonState;
}
--------------------------------------------------------------
Q9. Create a breathing LED effect where brightness eases in/out nonlinearly (slow start, faster middle, slow end).

// CONNECTIONS:
// LED anode (long)  -> D9 (PWM) through 220Ω
// LED cathode       -> GND

const int ledPin = 9;

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Breathing LED Effect Started");
}

void loop() {
  for (float i = 0; i < PI; i += 0.02) {
    float brightness = (sin(i) * 255);  
    
    if (brightness < 0) brightness = 0;

    analogWrite(ledPin, (int)brightness);
    Serial.println((int)brightness);
    delay(15);
  }
}
-----------------------------------------------------------------------------
Q10. Continuously measure analog voltage from A0. If the voltage changes rapidly (difference > 0.5V), print readings frequently (every 100 ms). 
     If stable, print slowly (every 1 second).
// CONNECTIONS:
// Pot wiper (middle) -> A0
// Pot outer 1        -> 5V
// Pot outer 2        -> GND

const int analogPin = A0;
float currentVoltage = 0.0;
float previousVoltage = 0.0;
float diff = 0.0;
int delayTime = 1000;

void setup() {
  Serial.begin(9600);
  Serial.println("Adaptive Voltage Measurement Started");
  previousVoltage = analogRead(analogPin) * (5.0 / 1023.0);
}

void loop() {
  int adcValue = analogRead(analogPin);
  currentVoltage = adcValue * (5.0 / 1023.0);
  diff = fabsf(currentVoltage - previousVoltage);
  // Determine rate of change
  if (diff > 0.5) {
    delayTime = 100;  // Rapid change → frequent readings
  } else {
    delayTime = 1000; // Stable voltage → slow readings
  }

  // Display results
  Serial.print("Voltage: ");
  Serial.print(currentVoltage, 2);
  Serial.print(" V\tChange: ");
  Serial.print(diff, 2);
  Serial.print(" V\tDelay: ");
  Serial.print(delayTime);
  Serial.println(" ms");

  previousVoltage = currentVoltage;
  delay(delayTime);
}
---------------------------------------------------------------------------

Q1. A potentiometer is connected to an analog input pin of the Arduino UNO. 
  The analog value (0â€“1023) must be read, displayed on the Serial Monitor, and mapped to control the brightness of an LED connected to a PWM pin (e.g., pin 9). 
  The LED should glow with varying intensity corresponding to the potentiometer position.
// CONNECTIONS:
// Potentiometer wiper (middle) -> A0
// Potentiometer outer 1        -> 5V
// Potentiometer outer 2        -> GND
// LED anode (long leg)         -> D9 (PWM) through 220Î©
// LED cathode (short leg)      -> GND

const int POT_PIN = A0;
const int LED_PIN = 9;

void setup() {
  Serial.begin(9600);
  pinMode(LED_PIN, OUTPUT);
}

void loop() {
  int adc = analogRead(POT_PIN);              // 0..1023
  int pwm = map(adc, 0, 1023, 0, 255);        // 0..255
  analogWrite(LED_PIN, pwm);
  Serial.print("ADC: ");
  Serial.print(adc);
  Serial.print("  PWM: ");
  Serial.println(pwm);
  delay(50);
}
-------------------------------------------------------------------
Q2. Design an Arduino program to read the state of a push button connected to a digital input pin and display its status (â€œButton Pressedâ€ / â€œButton Releasedâ€) on the Serial Monitor. 
    When the button is pressed, the on-board LED (pin 13) should turn ON; otherwise, it should remain OFF.
// CONNECTIONS:
// Button side 1          -> 5V
// Button side 2          -> D2
// Same as D2             -> 10kÎ© -> GND  (external pull-down)
// Using onboard LED at D13

const int BTN_PIN = 2;
const int LED_PIN = 13;

void setup() {
  pinMode(BTN_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(9600);
}

void loop() {
  int state = digitalRead(BTN_PIN);
  if (state == HIGH) {
    Serial.println("Button Pressed");
    digitalWrite(LED_PIN, HIGH);
  } else {
    Serial.println("Button Released");
    digitalWrite(LED_PIN, LOW);
  }
  delay(80); // brief debounce/settle
}
-------------------------------------------------------------
ðŸ”¹ Q3. Control the on-board LED (pin 13) to blink in different patterns based on user input via Serial Monitor:
        Mode 1 = 1s ON / 1s OFF, Mode 2 = 200ms ON / 200ms OFF, Mode 3 = Gradual ON duration from 100ms to 1000ms (reset, repeat).
// CONNECTIONS:
// USB only for Serial
// Using onboard LED at D13

const int ledPin = 13;
char userInput;
int mode = 0;  

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);

  Serial.println("=== LED Blink Controller ===");
  Serial.println("Enter a mode:");
  Serial.println("1 - Standard Blink (1s ON, 1s OFF)");
  Serial.println("2 - Fast Blink (200ms ON, 200ms OFF)");
  Serial.println("3 - Gradual Blink (100ms â†’ 1000ms)");
  Serial.println("S - Stop Blinking");
  Serial.println("=============================");
}

void loop() {
  // --- Read User Input ---
  if (Serial.available() > 0) {
    userInput = Serial.read();       // Read the character
    if (userInput == '1') {
      mode = 1;
      Serial.println("Mode 1 Selected: Standard Blink");
    }
    else if (userInput == '2') {
      mode = 2;
      Serial.println("Mode 2 Selected: Fast Blink");
    }
    else if (userInput == '3') {
      mode = 3;
      Serial.println("Mode 3 Selected: Gradual Blink");
    }
    else if (userInput == 'S' || userInput == 's') {
      mode = 0;
      digitalWrite(ledPin, LOW);
      Serial.println("Blinking stopped. LED OFF.");
    }
    else {
      Serial.println("Invalid input! Enter 1, 2, 3, or S.");
    }
  }

  // --- Execute Blinking Pattern ---
  switch (mode) {
    case 1: // Standard Blink
      digitalWrite(ledPin, HIGH);
      Serial.println("Mode 1: LED ON (1s)");
      delay(1000);
      digitalWrite(ledPin, LOW);
      Serial.println("Mode 1: LED OFF (1s)");
      delay(1000);
      break;

    case 2: // Fast Blink
      digitalWrite(ledPin, HIGH);
      Serial.println("Mode 2: LED ON (200ms)");
      delay(200);
      digitalWrite(ledPin, LOW);
      Serial.println("Mode 2: LED OFF (200ms)");
      delay(200);
      break;

    case 3: // Gradual Blink
      for (int onTime = 100; onTime <= 1000 && mode == 3; onTime += 100) {
        digitalWrite(ledPin, HIGH);
        Serial.print("Mode 3: LED ON (");
        Serial.print(onTime);
        Serial.println(" ms)");
        delay(onTime);

        digitalWrite(ledPin, LOW);
        Serial.println("Mode 3: LED OFF (200 ms)");
        delay(200);

        // Check for stop command during gradual loop
        if (Serial.available() > 0) {
          char temp = Serial.read();
          if (temp == 'S' || temp == 's') {
            mode = 0;
            digitalWrite(ledPin, LOW);
            Serial.println("Blinking stopped during Mode 3.");
            break;
          }
        }
      }
      break;

    default:
      // Mode = 0 (stopped) or invalid
      digitalWrite(ledPin, LOW);
      break;
  }
}
----------------------------------------------
Q4. Gradually increase and decrease the brightness of an LED on a PWM pin (e.g., D9) using PWM. 
    Display the PWM values on the Serial Monitor.
// CONNECTIONS:
// LED anode (long)  -> D9 (PWM) through 220Î©
// LED cathode       -> GND

const int LED_PIN = 9;

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(9600);
}

void loop() {
  for (int b = 0; b <= 255; b++) {
    analogWrite(LED_PIN, b);
    Serial.print("PWM: "); Serial.println(b);
    delay(5);
  }
  for (int b = 255; b >= 0; b--) {
    analogWrite(LED_PIN, b);
    Serial.print("PWM: "); Serial.println(b);
    delay(5);
  }
}
------------------------------------------------------------------
Q5. Measure an analog voltage (0â€“5V) on A0, convert ADC to voltage, print both ADC and voltage to Serial Monitor, and stream voltage for Serial Plotter.
// CONNECTIONS:
// Pot wiper (middle) -> A0
// Pot outer 1        -> 5V
// Pot outer 2        -> GND

const int ANALOG_PIN = A0;
const float VREF = 5.0;   // UNO default reference
const int ADC_MAX = 1023; // 10-bit

void setup() {
  Serial.begin(9600);
  // Serial Plotter tip: print ONLY voltage in a single line if you want a clean plot
}

void loop() {
  int adc = analogRead(ANALOG_PIN);
  float volt = adc * (VREF / ADC_MAX);

  // Full info for Serial Monitor:
  Serial.print("ADC=");
  Serial.print(adc);
  Serial.print("  V=");
  Serial.println(volt);

  // If you want Plotter-only line, uncomment below:
  // Serial.println(volt);

  delay(200);
}
-----------------------------------------------------------------------
Q6. Read analog input from a potentiometer and determine whether the knob is rotating clockwise, counterclockwise, or not moving, with a small threshold for noise.
// CONNECTIONS:
// Pot wiper (middle) -> A0
// Pot outer 1        -> 5V
// Pot outer 2        -> GND

const int ANALOG_PIN = A0;
int prevVal = 0;
const int THRESH = 5;   // noise threshold (ADC counts)

void setup() {
  Serial.begin(9600);
  prevVal = analogRead(ANALOG_PIN);
}

void loop() {
  int curVal = analogRead(ANALOG_PIN);

  if (curVal > prevVal + THRESH) {
    Serial.println("Rotating Clockwise");
  } else if (curVal < prevVal - THRESH) {
    Serial.println("Rotating Counterclockwise");
  } else {
    Serial.println("No Movement");
  }

  prevVal = curVal;
  delay(200);
}
----------------------------------------------------------------
Q7. Blink the on-board LED using delays that follow the Fibonacci sequence in milliseconds (e.g., 100, 100, 200, 300, 500, 800, â€¦). 
    After the 8th term, restart.
// CONNECTIONS:
// Using onboard LED at D13

const int LED_PIN = 13;

void setup() {
  pinMode(LED_PIN, OUTPUT);
}

void loop() {
  int a = 100;
  int b = 100;

  for (int i = 0; i < 8; i++) {
    digitalWrite(LED_PIN, HIGH); delay(a);
    digitalWrite(LED_PIN, LOW ); delay(a);
    int next = a + b;
    a = b;
    b = next;
  }
  // loop restarts; sequence resets automatically next iteration
}
------------------------------------------------------------------
Q8. Use a push button on D2. Each short press increases a counter by 1 and prints it on Serial. 
    Holding for â‰¥3 seconds resets the counter to 0.
// CONNECTIONS:
// Button side 1 -> 5V
// Button side 2 -> D2
// Same as D2    -> 10kÎ© -> GND (pull-down)

const int BTN_PIN = 2;
int lastState = LOW;
unsigned long pressStart = 0;
unsigned long longPressMs = 3000;
long counter = 0;

void setup() {
  pinMode(BTN_PIN, INPUT);
  Serial.begin(9600);
}

void loop() {
  int state = digitalRead(BTN_PIN);

  // Rising edge = button just pressed
  if (state == HIGH && lastState == LOW) {
    pressStart = millis();
  }

  // Falling edge = button just released
  if (state == LOW && lastState == HIGH) {
    unsigned long dur = millis() - pressStart;
    if (dur < longPressMs) {
      counter++;
    } else {
      counter = 0;
    }
    Serial.print("Count: ");
    Serial.println(counter);
  }

  lastState = state;
  delay(10); // small poll delay
}
--------------------------------------------------------------
Q9. Create a breathing LED effect where brightness eases in/out nonlinearly (slow start, faster middle, slow end).

// CONNECTIONS:
// LED anode (long)  -> D9 (PWM) through 220Î©
// LED cathode       -> GND

#include <math.h>

const int LED_PIN = 9;

void setup() {
  pinMode(LED_PIN, OUTPUT);
}

void loop() {
  // One full breath cycle using sine: 0..360 degrees
  for (int deg = 0; deg < 360; deg++) {
    // Map sin(-) from [-1,1] to [0,255]
    float s = sin(deg * PI / 180.0);
    int pwm = (int)((s + 1.0) * 127.5);
    analogWrite(LED_PIN, pwm);
    delay(15);
  }
}
-----------------------------------------------------------------------------
Q10. Continuously measure analog voltage from A0. If the voltage changes rapidly (difference > 0.5V), print readings frequently (every 100 ms). 
     If stable, print slowly (every 1 second).

âœ… Answer:

// CONNECTIONS:
// Pot wiper (middle) -> A0
// Pot outer 1        -> 5V
// Pot outer 2        -> GND

const int ANALOG_PIN = A0;
const float VREF = 5.0;
const int ADC_MAX = 1023;
float prevV = 0.0;

void setup() {
  Serial.begin(9600);
  prevV = analogRead(ANALOG_PIN) * (VREF / ADC_MAX);
}

void loop() {
  float curV = analogRead(ANALOG_PIN) * (VREF / ADC_MAX);
  float diff = fabs(curV - prevV);

  int delayMs = (diff > 0.5) ? 100 : 1000;

  Serial.print("Voltage: ");
  Serial.print(curV, 3);
  Serial.print(" V  |  Î”: ");
  Serial.println(diff, 3);

  prevV = curV;
  delay(delayMs);
}
---------------------------------------------------------------------------
